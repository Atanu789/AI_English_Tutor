import { GoogleGenerativeAI } from '@google/generative-ai';
import { PrismaClient } from '@prisma/client';
import express from 'express';
import { body, param, query, validationResult } from 'express-validator';
import fetch from 'node-fetch';

const router = express.Router();
const prisma = new PrismaClient();

// Middleware to handle validation errors
const handleValidationErrors = (req, res, next) => {
  const errors = validationResult(req);
  if (!errors.isEmpty()) {
    return res.status(400).json({ errors: errors.array() });
  }
  next();
};

// Helper function to authorize user
async function authorizeUser(email) {
  if (!email) {
    return { error: { status: 401, message: 'Unauthorized: email is required' } };
  }

  const user = await prisma.user.findUnique({ where: { email } });
  if (!user) {
    return { error: { status: 404, message: 'User not found' } };
  }

  return { user };
}

// Helper function to manage user's streak
async function manageUserStreak(userId) {
  const today = new Date();
  today.setHours(0, 0, 0, 0);

  // Check if user already has a streak for today
  const todayStreak = await prisma.dailyStreak.findUnique({
    where: {
      userId_date: {
        userId,
        date: today,
      },
    },
  });

  // If user already has a streak today, no need to update
  if (todayStreak) {
    return { streak: todayStreak.count, lastActive: today, updated: false };
  }

  // Check for yesterday's streak
  const yesterday = new Date(today);
  yesterday.setDate(yesterday.getDate() - 1);

  const yesterdayStreak = await prisma.dailyStreak.findUnique({
    where: {
      userId_date: {
        userId,
        date: yesterday,
      },
    },
  });

  let newCount = 1; // Default to starting a new streak

  // If there was activity yesterday, continue the streak
  if (yesterdayStreak) {
    newCount = yesterdayStreak.count + 1;
  } else {
    // Check if there was any recent streak (within last 2 days to allow for 1-day miss)
    const twoDaysAgo = new Date(today);
    twoDaysAgo.setDate(twoDaysAgo.getDate() - 2);

    const twoDaysAgoStreak = await prisma.dailyStreak.findUnique({
      where: {
        userId_date: {
          userId,
          date: twoDaysAgo,
        },
      },
    });

    // If missed just one day, we can be lenient and continue the streak
    // but don't increment for the missed day
    if (twoDaysAgoStreak) {
      newCount = twoDaysAgoStreak.count + 1;
    }
  }

  // Create today's streak
  const updatedStreak = await prisma.dailyStreak.create({
    data: {
      userId,
      date: today,
      count: newCount,
    },
  });

  return { streak: newCount, lastActive: today, updated: true };
}

/**
 * Search for a word in external dictionary API
 */
const MODEL_NAME = "gemini-2.0-flash"; // Use appropriate model version
const API_KEY = process.env.GEMINI_API_KEY; // Store this in your .env file
const genAI = new GoogleGenerativeAI(API_KEY);
const model = genAI.getGenerativeModel({ model: MODEL_NAME });

/**
 * Generate a word description using Google's Gemini API
 * @param {string} word - The word to get a description for
 * @returns {Promise<Object>} - Formatted word information object
 */
async function generateWordDescription(word) {
  try {
    const prompt = `Generate a comprehensive dictionary entry for the word "${word}".

    Format the response as a JSON object with the following structure:
    {
      "word": "${word}",
      "phonetic": "phonetic transcription if possible",
      "origin": "etymology and origin information",
      "meanings": [
        {
          "partOfSpeech": "noun/verb/adjective/etc.",
          "definitions": [
            {
              "definition": "clear definition",
              "example": "example sentence using the word",
              "synonyms": ["synonym1", "synonym2"]
            }
          ]
        }
      ]
    }

    Include at least 2-3 different meanings if applicable (different parts of speech or distinctly different definitions).
    Provide realistic examples showing how the word is used in context.
    Include common synonyms where appropriate.
    IMPORTANT: Respond ONLY with the JSON object, no additional text.`;

    const result = await model.generateContent(prompt);
    const response = await result.response;
    console.log(`Gemini API response for word "${word}":`, response.text());
    const text = response.text();

    // Parse the JSON response
    let jsonResponse;
    try {
      // Extract JSON if it's wrapped in markdown code blocks
      const jsonMatch = text.match(/```json\n([\s\S]*?)\n```/) || text.match(/```\n([\s\S]*?)\n```/);
      const jsonText = jsonMatch ? jsonMatch[1] : text;
      jsonResponse = JSON.parse(jsonText);
    } catch (parseError) {
      console.error("Error parsing Gemini response:", parseError);
      // If parsing fails, create a basic structure
      jsonResponse = {
        word: word,
        phonetic: "",
        origin: "Generated by AI",
        meanings: [
          {
            partOfSpeech: "unknown",
            definitions: [
              {
                definition: "Unable to parse the complete definition. The word may be very uncommon or specialized.",
                example: "",
                synonyms: []
              }
            ]
          }
        ],
        isAIGenerated: true
      };
    }

    // Always mark as AI generated
    jsonResponse.isAIGenerated = true;
    console.log(`Generated description for "${word}":`, jsonResponse);
    return jsonResponse;
  } catch (error) {
    console.error("Error generating word description:", error);
    throw new Error("Failed to generate word description");
  }
}

// Add this to your search endpoint
router.get(
  '/search/:word',
  param('word').trim().isString().isLength({ min: 1 }),
  query('email').isEmail(),
  handleValidationErrors,
  async (req, res) => {
    try {
      const { word } = req.params;
      const { email } = req.query;

      // Authorize user
      const { user, error } = await authorizeUser(email);
      if (error) return res.status(error.status).json({ message: error.message });

      // Record search in history
      await prisma.searchHistory.create({
        data: {
          term: word.toLowerCase(),
          userId: user.id,
        },
      });

      // Fetch word details from external API
      const apiUrl = `https://api.dictionaryapi.dev/api/v2/entries/en/${encodeURIComponent(word.toLowerCase())}`;

      const response = await fetch(apiUrl);

      if (response.ok) {
        // Dictionary API found the word
        const data = await response.json();
        return res.json(data[0]); // Return the first entry (most relevant)
      } else {
        // Word not found in dictionary, use Gemini to generate description
        try {
          console.log(`Word "${word}" not found in dictionary, generating with Gemini API`);
          const generatedDescription = await generateWordDescription(word);

          // Log that we're using AI generation
          await prisma.aIGeneration.create({
            data: {
              word: word.toLowerCase(),
              userId: user.id,
              timestamp: new Date()
            }
          }).catch(err => {
            // If table doesn't exist yet, just log and continue
            console.log("Note: aiGeneration tracking table not available");
          });

          return res.json(generatedDescription);
        } catch (aiError) {
          console.error("Error using Gemini API:", aiError);
          return res.status(404).json({
            message: 'Word not found in dictionary and AI generation failed',
            originalError: response.status
          });
        }
      }
    } catch (error) {
      console.error('Error searching for word:', error);
      res.status(500).json({ message: 'Failed to search for word' });
    }
  }
);

/**
 * Get random words with improved error handling and caching
 */
router.get('/random', async (req, res) => {
  try {
    const limit = Math.min(parseInt(req.query.limit) || 10, 100); // Enforce upper limit

    // Fetch random words from external API
    const response = await fetch('https://random-word-api.herokuapp.com/all');

    if (!response.ok) {
      return res.status(500).json({ message: 'Failed to fetch random words' });
    }

    const words = await response.json();

    // Use a more efficient approach for random selection
    const randomWords = [];
    const totalWords = words.length;
    const usedIndices = new Set();

    while (randomWords.length < limit && usedIndices.size < totalWords) {
      const randomIndex = Math.floor(Math.random() * totalWords);
      if (!usedIndices.has(randomIndex)) {
        randomWords.push(words[randomIndex]);
        usedIndices.add(randomIndex);
      }
    }

    res.json(randomWords);
  } catch (error) {
    console.error('Error fetching random words:', error);
    res.status(500).json({ message: 'Failed to fetch random words' });
  }
});

/**
 * Save word to user's vocabulary
 */
router.post(
  '/words',
  body('email').isEmail(),
  body('word').trim().isString().isLength({ min: 1 }),
  body('phonetic').optional(),
  body('origin').optional(),
  body('meanings').isArray(),
  handleValidationErrors,
  async (req, res) => {
    try {
      const { email, word, phonetic, origin, meanings } = req.body;

      // Authorize user
      const { user, error } = await authorizeUser(email);
      if (error) return res.status(error.status).json({ message: error.message });

      // Check if word already exists for this user
      const existingWord = await prisma.vocabularyWord.findFirst({
        where: {
          word: word.toLowerCase(),
          userId: user.id
        }
      });

      if (existingWord) {
        // Update existing word
        const updatedWord = await prisma.vocabularyWord.update({
          where: { id: existingWord.id },
          data: {
            phonetic,
            origin,
            meanings,
            timestamp: new Date() // Update timestamp to mark as "recent"
          }
        });
        return res.status(200).json(updatedWord);
      }

      // Add new word to vocabulary
      const newWord = await prisma.vocabularyWord.create({
        data: {
          word: word.toLowerCase(),
          phonetic,
          origin,
          meanings,
          userId: user.id,
        },
      });

      res.status(201).json(newWord);
    } catch (error) {
      console.error('Error saving word:', error);
      res.status(500).json({ message: 'Failed to save word' });
    }
  }
);

/**
 * Get user's vocabulary with optimized database queries
 */
router.get(
  '/words',
  query('email').isEmail(),
  handleValidationErrors,
  async (req, res) => {
    try {
      const { email } = req.query;

      // Authorize user
      const { user, error } = await authorizeUser(email);
      if (error) return res.status(error.status).json({ message: error.message });

      const filter = req.query.filter || 'all'; // 'all', 'favorites', 'recent'
      const page = parseInt(req.query.page) || 1;
      const pageSize = parseInt(req.query.pageSize) || 50;
      const skip = (page - 1) * pageSize;

      // Base query conditions
      const baseWhere = { userId: user.id };

      // Filter conditions
      let where = { ...baseWhere };
      if (filter === 'favorites') {
        where = {
          ...baseWhere,
          favorites: {
            some: {
              userId: user.id,
            },
          },
        };
      }

      // Get words with pagination
      const [words, totalCount] = await Promise.all([
        prisma.vocabularyWord.findMany({
          where,
          orderBy: {
            timestamp: 'desc',
          },
          skip,
          take: pageSize,
        }),
        prisma.vocabularyWord.count({ where })
      ]);

      // If no words found, return empty array
      if (words.length === 0) {
        return res.json({
          words: [],
          pagination: {
            total: 0,
            page,
            pageSize,
            pages: 0
          }
        });
      }

      // Get favorites in a single query
      const wordIds = words.map(word => word.id);
      const favorites = await prisma.favorite.findMany({
        where: {
          userId: user.id,
          wordId: { in: wordIds },
        },
      });

      const favoriteIds = new Set(favorites.map(fav => fav.wordId));

      // Add isFavorite flag to words
      const wordsWithFavoriteFlag = words.map(word => ({
        ...word,
        isFavorite: favoriteIds.has(word.id),
      }));

      res.json({
        words: wordsWithFavoriteFlag,
        pagination: {
          total: totalCount,
          page,
          pageSize,
          pages: Math.ceil(totalCount / pageSize)
        }
      });
    } catch (error) {
      console.error('Error fetching vocabulary:', error);
      res.status(500).json({ message: 'Failed to fetch vocabulary' });
    }
  }
);

/**
 * Delete a word from vocabulary
 */
router.delete(
  '/words/:id',
  param('id').isString(),
  body('email').isEmail(),
  handleValidationErrors,
  async (req, res) => {
    try {
      const { id } = req.params;
      const { email } = req.body;

      // Authorize user
      const { user, error } = await authorizeUser(email);
      if (error) return res.status(error.status).json({ message: error.message });

      // Check if word exists and belongs to user
      const word = await prisma.vocabularyWord.findFirst({
        where: {
          id,
          userId: user.id,
        },
      });

      if (!word) {
        return res.status(404).json({ message: 'Word not found' });
      }

      // Delete word and associated records in a transaction
      await prisma.$transaction([
        // Delete associated favorites
        prisma.favorite.deleteMany({
          where: { wordId: id }
        }),

        // Delete associated study records
        prisma.studyRecord.deleteMany({
          where: { wordId: id }
        }),

        // Delete the word itself
        prisma.vocabularyWord.delete({
          where: { id }
        })
      ]);

      res.status(204).send();
    } catch (error) {
      console.error('Error deleting word:', error);
      res.status(500).json({ message: 'Failed to delete word' });
    }
  }
);

/**
 * Toggle word as favorite with optimized database operations
 */
router.post(
  '/favorites',
  body('email').isEmail(),
  body('wordId').isString(),
  handleValidationErrors,
  async (req, res) => {
    try {
      const { email, wordId } = req.body;

      // Authorize user
      const { user, error } = await authorizeUser(email);
      if (error) return res.status(error.status).json({ message: error.message });

      // Check if word exists and belongs to user
      const word = await prisma.vocabularyWord.findFirst({
        where: {
          id: wordId,
          userId: user.id,
        },
      });

      if (!word) {
        return res.status(404).json({ message: 'Word not found' });
      }

      // Check if already favorite
      const existingFavorite = await prisma.favorite.findUnique({
        where: {
          userId_wordId: {
            userId: user.id,
            wordId,
          },
        },
      });

      if (existingFavorite) {
        // Remove from favorites
        await prisma.favorite.delete({
          where: {
            id: existingFavorite.id,
          },
        });

        return res.json({ isFavorite: false, wordId });
      }

      // Add to favorites
      await prisma.favorite.create({
        data: {
          userId: user.id,
          wordId,
        },
      });

      res.json({ isFavorite: true, wordId });
    } catch (error) {
      console.error('Error toggling favorite:', error);
      res.status(500).json({ message: 'Failed to toggle favorite' });
    }
  }
);

/**
 * Start a study session with improved streak handling
 */
router.post(
  '/study-sessions',
  body('email').isEmail(),
  body('mode').isIn(['study', 'flashcard']),
  handleValidationErrors,
  async (req, res) => {
    try {
      const { email, mode } = req.body;

      // Authorize user
      const { user, error } = await authorizeUser(email);
      if (error) return res.status(error.status).json({ message: error.message });

      // Create new study session
      const session = await prisma.studySession.create({
        data: {
          userId: user.id,
          mode,
          startTime: new Date(),
        },
      });

      // Update daily streak
      const streakInfo = await manageUserStreak(user.id);

      res.status(201).json({
        session,
        streak: {
          count: streakInfo.streak,
          lastActive: streakInfo.lastActive
        }
      });
    } catch (error) {
      console.error('Error starting study session:', error);
      res.status(500).json({ message: 'Failed to start study session' });
    }
  }
);

/**
 * End a study session
 */
router.put(
  '/study-sessions/:id',
  param('id').isString(),
  body('email').isEmail(),
  handleValidationErrors,
  async (req, res) => {
    try {
      const { id } = req.params;
      const { email } = req.body;

      // Authorize user
      const { user, error } = await authorizeUser(email);
      if (error) return res.status(error.status).json({ message: error.message });

      // Check if session exists and belongs to user
      const session = await prisma.studySession.findFirst({
        where: {
          id,
          userId: user.id,
        },
      });

      if (!session) {
        return res.status(404).json({ message: 'Study session not found' });
      }

      // Update session with end time
      const updatedSession = await prisma.studySession.update({
        where: {
          id,
        },
        data: {
          endTime: new Date(),
        },
      });

      // Calculate session duration in minutes
      const durationMs = updatedSession.endTime.getTime() - updatedSession.startTime.getTime();
      const durationMinutes = Math.round(durationMs / 60000);

      res.json({
        ...updatedSession,
        durationMinutes
      });
    } catch (error) {
      console.error('Error ending study session:', error);
      res.status(500).json({ message: 'Failed to end study session' });
    }
  }
);

/**
 * Record word study attempt with optimized error handling
 */
router.post(
  '/study-records',
  body('email').isEmail(),
  body('sessionId').isString(),
  body('wordId').isString(),
  body('difficultyRating').optional().isIn(['easy', 'medium', 'hard']),
  body('isCorrect').optional().isBoolean(),
  body('timeSpent').optional().isInt(),
  handleValidationErrors,
  async (req, res) => {
    try {
      const { email, sessionId, wordId, difficultyRating, isCorrect, timeSpent } = req.body;

      // Authorize user
      const { user, error } = await authorizeUser(email);
      if (error) return res.status(error.status).json({ message: error.message });

      // Check sessions and words in a single query
      const [session, word] = await Promise.all([
        prisma.studySession.findFirst({
          where: {
            id: sessionId,
            userId: user.id,
          },
        }),
        prisma.vocabularyWord.findFirst({
          where: {
            id: wordId,
            userId: user.id,
          },
        })
      ]);

      if (!session) {
        return res.status(404).json({ message: 'Study session not found' });
      }

      if (!word) {
        return res.status(404).json({ message: 'Word not found' });
      }

      // Create study record
      const record = await prisma.studyRecord.create({
        data: {
          sessionId,
          wordId,
          difficultyRating,
          isCorrect,
          timeSpent,
        },
      });

      // Update word's last studied timestamp
      await prisma.vocabularyWord.update({
        where: { id: wordId },
        data: { lastStudied: new Date() }
      });

      res.status(201).json(record);
    } catch (error) {
      console.error('Error creating study record:', error);
      res.status(500).json({ message: 'Failed to create study record' });
    }
  }
);

/**
 * Get user's current streak with improved streak calculation
 */
router.get(
  '/streak',
  query('email').isEmail(),
  handleValidationErrors,
  async (req, res) => {
    try {
      const { email } = req.query;

      // Authorize user
      const { user, error } = await authorizeUser(email);
      if (error) return res.status(error.status).json({ message: error.message });

      const today = new Date();
      today.setHours(0, 0, 0, 0);

      // Find the most recent streak
      const recentStreaks = await prisma.dailyStreak.findMany({
        where: {
          userId: user.id,
        },
        orderBy: {
          date: 'desc',
        },
        take: 3, // Get the last few entries to check continuity
      });

      if (recentStreaks.length === 0) {
        return res.json({
          streak: 0,
          lastActive: null,
          currentDay: false,
          nextMilestone: 1
        });
      }

      const mostRecentStreak = recentStreaks[0];
      const mostRecentDate = new Date(mostRecentStreak.date);

      // Check if the most recent streak is from today
      const isToday = mostRecentDate.toDateString() === today.toDateString();

      // If not today, check if it was yesterday (streak still active but not logged today)
      const yesterday = new Date(today);
      yesterday.setDate(yesterday.getDate() - 1);

      const isYesterday = mostRecentDate.toDateString() === yesterday.toDateString();

      // Calculate next milestone (next multiple of 5)
      const currentCount = mostRecentStreak.count;
      const nextMilestone = Math.ceil((currentCount + 1) / 5) * 5;

      res.json({
        streak: currentCount,
        lastActive: mostRecentDate,
        currentDay: isToday,
        streakActive: isToday || isYesterday,
        nextMilestone
      });
    } catch (error) {
      console.error('Error fetching streak:', error);
      res.status(500).json({ message: 'Failed to fetch streak' });
    }
  }
);

/**
 * Get search history with improved duplicate handling
 */
router.get(
  '/search-history',
  query('email').isEmail(),
  handleValidationErrors,
  async (req, res) => {
    try {
      const { email } = req.query;

      // Authorize user
      const { user, error } = await authorizeUser(email);
      if (error) return res.status(error.status).json({ message: error.message });

      const limit = Math.min(parseInt(req.query.limit) || 20, 100); // Add upper limit

      // Get all search history items
      const history = await prisma.searchHistory.findMany({
        where: {
          userId: user.id,
        },
        orderBy: {
          timestamp: 'desc',
        },
        select: {
          term: true,
          timestamp: true,
        },
      });

      // Remove duplicates keeping only the most recent entry for each term
      const uniqueTerms = new Map();

      history.forEach((item) => {
        if (!uniqueTerms.has(item.term) ||
            new Date(uniqueTerms.get(item.term).timestamp) < new Date(item.timestamp)) {
          uniqueTerms.set(item.term, item);
        }
      });

      // Convert map to array and sort by timestamp (most recent first)
      const uniqueHistory = Array.from(uniqueTerms.values())
        .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
        .slice(0, limit);

      res.json(uniqueHistory);
    } catch (error) {
      console.error('Error fetching search history:', error);
      res.status(500).json({ message: 'Failed to fetch search history' });
    }
  }
);

/**
 * Get streak statistics
 */
router.get(
  '/streak-stats',
  query('email').isEmail(),
  handleValidationErrors,
  async (req, res) => {
    try {
      const { email } = req.query;

      // Authorize user
      const { user, error } = await authorizeUser(email);
      if (error) return res.status(error.status).json({ message: error.message });

      const today = new Date();
      today.setHours(0, 0, 0, 0);

      // Get current streak
      const currentStreak = await prisma.dailyStreak.findUnique({
        where: {
          userId_date: {
            userId: user.id,
            date: today,
          },
        },
      });

      // If no streak today, check yesterday
      const yesterday = new Date(today);
      yesterday.setDate(yesterday.getDate() - 1);

      let streakInfo = { streak: 0, lastActive: null };

      if (currentStreak) {
        streakInfo = {
          streak: currentStreak.count,
          lastActive: today
        };
      } else {
        // Check yesterday's streak
        const yesterdayStreak = await prisma.dailyStreak.findUnique({
          where: {
            userId_date: {
              userId: user.id,
              date: yesterday,
            },
          },
        });

        if (yesterdayStreak) {
          streakInfo = {
            streak: yesterdayStreak.count,
            lastActive: yesterday
          };
        }
      }

      // Get the longest streak ever
      const longestStreak = await prisma.dailyStreak.findFirst({
        where: { userId: user.id },
        orderBy: { count: 'desc' },
        select: { count: true, date: true }
      });

      // Get total days with activity
      const totalDays = await prisma.dailyStreak.count({
        where: { userId: user.id }
      });

      // Get total study sessions
      const totalSessions = await prisma.studySession.count({
        where: { userId: user.id }
      });

      res.json({
        currentStreak: streakInfo.streak,
        longestStreak: longestStreak?.count || 0,
        longestStreakDate: longestStreak?.date || null,
        totalDays,
        totalSessions,
        nextMilestone: Math.ceil((streakInfo.streak + 1) / 5) * 5,
        lastActive: streakInfo.lastActive
      });
    } catch (error) {
      console.error('Error fetching streak stats:', error);
      res.status(500).json({ message: 'Failed to fetch streak statistics' });
    }
  }
);

export default router;
